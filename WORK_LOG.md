Name: Kieran Pichai

| Date    |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Update |
|:--------|:-----------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Oct. 10 | 11:15am - 11:55am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     This session during class I talked with Tony and Isha at the whiteboard about potential solutions to this problem. Immediately we identified the biggest thing which is zoning, being able to eliminate large parts of the dataset efficiently so that you have to search less and less of it each time. Thus, this helps with efficiency. Similarly: we tried to apply bit shifting techniques to see if there are more efficient ways to loop through this string dataset. Lastly, I was thinking maybe stacks or some sort of map of stacks could be utilized to check the order of repeats. However, this would still run in linear time as it wouldn't eliminate any sections. |
| Oct. 13 |  8:00pm - 8:35pm  |                                                                                                                                                                                                                                                                                                                                                                                                         Thought more about different solutions to this problem, I continued with the stack idea and was thinking about how if we use a map, a map for each base (ACTG) that mapped to a stack which would contain the index of the most recent instance of that base. From there on we could loop through the stack while being able to skip large chunks of each stack if a base was misrepresented or broke the pattern. Similarly, I thought about how to integrate this with landon's idea of separating the overall list of bases into subsections that can searched, his idea helps with minimizing the number of elements searched in total which is the biggest efficiency boost you can have. I'n not sold on the idea that this is the right approach to this problem but its interesting to think about, I'm still somewhat confident this problem set will trend in the direction of integer bit scale math operations, bitwise operations. |
| Oct. 14 |  8:55am - 9:25am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             During class we talked about more potential solutions to this problem. I continued to talk about my idea of representing each base as a pair of 2 bits. For example, A would be 00, C would be 01, T would be 10, and G would be 11. This allows us to mathematically and numerically encode each set of bases into a unique integer. Because, in binary there is only 1 way to represent the number 7 in an 8 bit system, 000000111. Similarly, this would allow us to represent 4 bases uniquely as a 8 bit integer. 10000111 would represent TACG, there is no other way to represent that string with this bit system making it unique. |
| Oct. 14 |  9:25am - 9:55am  |                                                                                                                                                                                                                                                                                                                                                                                                                                After thinking about the merits and possibilities of this system me Tony and Isha began to discuss edge cases in which you might miss parts of longest repeats if you just iterated by the length of the STR. For example, if your STR was AGA, and you sequence was AGAGAAGAAGA. If you iterated normally and saw the first AGA but then skipped the rest because they were still AGA, but shifted incorreclty you only wouldve gotten 1 STR. However, in this case the longest STR repeat cycle is 3. Similarly, we came up with the idea of using bit shifting as our method of iterating through the array rather than construcuting and comparing with .equals for strings, instead if we use the concept above and bit shift by 2 then add the 2 bits that correspond to A for example we could effectively iterate through the sequence. I then began to code a function that encodes a given string into binary. |
| Oct. 14 |  8:30pm - 9:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   I attempted to fix my code making function after simply printing out the values it was generating. Intiially, it had issues with bit shifting, so I changed the logic of the for loop and then it worked. I tested different permutaitons of ACTG (TAGC, GATC, etc) to see if it acted as expected and it did. In the meanwhile I also brainstormed more ways to solve the issue above, me and tony had talked about using an arraylist to keep track of all the possible starting places of a new sequence so that you wouldn't need one but I'm trying to think of a potentially more efficient way of doing this without utilizing an arraylist. Isha mentioned just keeping a temporary variable of the very last possible STR repeat beginning you see, I think this idea has lots of merit and I will try to implement it soon. |
| Oct. 14 |  9:00pm - 9:45pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                               During this session I tried to code my result into effect and tested my code. I essentially created substrings of the original sequence and converted them to integers then bit shifted them to iterate thorugh them. I used this to check if we found a match along the way however this didn't work as when I tested the final result I got 0 consistently. I traced my code with the first example and got it close to working, for the first 3 test cases my result was 1 greater than the expected. However, it failed badly at the largest and chromosome 22 examples. I'll have to figure that issue out in the future though I'm glad it seems to be very close to working effectively. The error I realized was my logic for assigning and creating the next set of n bases (where n is the length of the the STR) was incorrect as it skipped certain segments on the sequence. |
| Oct. 20 |  1:00pm - 1:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     During this iteration I recoded my logic to avoid using substring on each instance of the loop. I coded this to use a unique hash function that I could increment in constant time. This works by simply bit shifting the int twice to get rid of the first char then add on the last char, both are constant time operations. I tested this out and the hashing seems to work (by printing stuff). |
| Oct. 20 |  1:30pm - 2:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Here, I moved forward in my coding and tried to add reduncancies into my code for some more special cases (lite the ones I named above where you have AGA as your STR and your sequence is AGAGAAGAAGA). I used a queue to keep track of each new place one of these str repetitions could start but upon testing my code it didn't seem to work at all. For my next iteration, I'll have to trace the code more thoroughly and really eliminate any errors. |
| Oct. 21 |  5:00pm - 5:30pm  | During this session, I really dove into re-checking my code and tracing it to see if I am getting any errors. While all my test cases weren't working, I decided to trace the basic one. Immediately, I saw one issue which was that my int that stored my hashed curSequence was incorrect. Each time, as I bit shifted << 2 to remove the front char I actually wasn't removing the front char as an int is 32 bits long. For example, if the each char takes up 2 bits and we have a STR length of 3 then we want our int to always have 2 leading zeroes (if an int only had 8 bits): 00xxxxxx. Where the x's can be 0's or 1's but the 00 at the front must always be there. I fixed this issue by using a 'mask', an integer with a bunch of 0's at the front then 1's. So that you can bitwise and it to the str to remove anything past what you want. The trick with this is that the mask changes based off how long your STR is. For example, if you STR is 3 chars long: your STR would have 26 0's then the last 6 bits would all be 1. Such that when you & it to a int, it turns all the leading bits to zeroes and correctly shift's the number. I did the mask generation by starting with 1 (assume it = 00000001), then bit shifting it by 2*STRlen, if str length = 3 then we get (01000000), then subtracting 1 to get (00111111). |
| Oct. 21 |  5:35pm - 6:10pm  |                                                                                                                                                                                                                                                                            After fixing that issue, I noticed more serious mistakes with my countMax function: the one that loops through everything in the sequence and actually determines what the real longest STR repeat is. I realized many flaws in it to the point i deleted everything inside the if statement and all my logic with using a queue then just rewrote it. The idea is as follows: I keep an array which has the same length of STR that counts how many repeats I have at each given offset. Everytime one of the repeat sections end, I then check if it is greater than the current max value, if so I update max. I set it to 0. This essentially serves as a repetition counter which is quite space efficient as well as time efficient, its not like a queue which I had previously used. I also added an exit early case in which you exit early if nothign is counting in the array and you physically don't have enough space left in the sequence to have a new max length of STR repeats. At the end of each loop instance I increment the curSequence by one index. |
| Oct. 21 |  6:15pm - 6:45pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 During this iteration, I tested the code and it worked: on all except for testLargest(). This was because I had an edge condiiton in which my code wasn't correctly checking if something had still been counting at the very end of the sequence (such that when you reach the end of the sequence you forget to update max). I fixed this issue by adding two if statements at the end of my code. One checking the very last curSequence, and one checking if any of the offests are still counting repeats that might be longer than max. After I fixed this small issue my code fully worked. Lastly, I made some small improvements to the run time by making my exit early case actually work (as the way I previously had it written did nothing) and also by changing my if else statements to switch case statements as I believe they are marginally faster. |
| Oct. 23 |  8:50am - 9:35am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Me and tony discussed optimizations, I ended up changing my code to add a map to access char int values rather than a switch case statement. This improved my codes runtime quite a bit across the board, we then code reviewed for a while and I changed some small things (removing repeated function class like length() that could be avoided). |


To add a new row to the table, click into a cell and then hit shift-enter.